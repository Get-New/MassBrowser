import Datastore from 'nedb'
import fs from 'fs'
import path from 'path'

const DATA_DIR = path.join(process.env.HOME, '.yaler')

if (!fs.existsSync(DATA_DIR)) {
  fs.mkdirSync(DATA_DIR)
}

function _createSchema(items) {
  var schema = {
    id: String
  }

  items.forEach(item => {
    var [name, fieldType] = item
    
    if (name.startsWith('_')) {
      return
    }

    if (fieldType == null || 
        fieldType === String || 
        typeof fieldType == 'string') {
      schema[name] = String
    } else if (fieldType === Number || 
        typeof fieldType == 'number') {
      schema[name] = Number
    } else if (fieldType instanceof RelationField) {
      schema[name] = fieldType
    } else {
      throw "Invalid field type for schema " + fieldType
    }
  })

  return schema
}

function _createModel(name, schemaModel, meta, datastore) {
  var schema = null

  const Model = class extends schemaModel {
    constructor() {
      super()

      // Schema object has to be created in constructor rather than being a prototype variable
      // since the SchemaModel fields are set in the contructor
      // We cache the schema object here to avoid creating it for each instance
      if (!schema) {
        schema = _createSchema(Object.entries(this)) 
      }
      
      // Set to null everything that doesn't have a default value
      Object.entries(schema).forEach(item => {
        var [name, fieldType] = item
        if (this[name] == String || this[name] == Number || this[name] instanceof RelationField) {
          this[name] = null
        }
      })


      // TODO needs optimization, take outside of constructor
      Object.entries(schema).forEach(item => {
        var [name, fieldType] = item

        if (!(fieldType instanceof RelationField)) {
          return
        } 

        var cacheKey = '_cached_' + name
        this[cacheKey] = null

        Object.defineProperty(this, name, {
          set: item => {
            this[cacheKey] = item
          },
          get: () => {
            if (this[cacheKey]) {
              return this[cacheKey]
            }
            return fieldType.relatedModel.findOne({id: this[name + '_id']})
          }
        })
      })
      
      this._schema = schema
      this.model = Model
      this._new_instance = true
    }

    static get name() {
      return name
    }
    
    static _promisize (func, args) {
      return new Promise((resolve, reject) => {
        var eArgs = Array.from(args)
        eArgs.push((err, result) => {
          if (err) {
            return reject(err)
          }
          return resolve(result)
        })
        func.apply(datastore, eArgs)
      })
    }

    static find (q) {
      console.log("[DATABASE] <find> " + this.name)
      if (q === undefined) {
        q = {}
      }
      return this._promisize(datastore.find, [q])
        .then(docs => docs.map(doc => this.docToModel(doc)))
    }

    static findOne (q) {
      console.log("[DATABASE] <findOne> " + this.name)
      if (q === undefined) {
        q = {}
      }
      return this._promisize(datastore.findOne, [q])
        .then(doc => doc ? this.docToModel(doc) : null)
    }

    static insert () {
      console.log("[DATABASE] <insert> " + this.name)
      return this._promisize(datastore.insert, arguments)
    }

    static update () {
      console.log("[DATABASE] <update> " + this.name)
      return this._promisize(datastore.update, arguments)
    }

    static docToModel(doc) {
      const obj = new Model()
      obj._new_instance = false

      Object.entries(schema).forEach(k => {
        var [name, fieldType] = k
        if (fieldType instanceof RelationField) {
          obj[name + '_id'] = doc[name]
        } else {
          obj[name] = doc[name]
        }
      })

      return obj
    }

    toObject() {
      return Object.entries(this._schema).reduce((o, k) => { 
        var [name, fieldType] = k
        if (fieldType instanceof RelationField) {
          
          if (this[name + '_id'] !== undefined) {
            o[name] = this[name + '_id']
          } else if (this[name] instanceof fieldType.relatedModel) {
            o[name] = this[name].id
          } else {
            o[name] = this[name]
          }
          
        } else {
          o[name] = this[name]
        }
        return o
      }, {})
    }

    save() {
      const insert = () => {
        return this.constructor.insert(this.toObject())
          .then(doc => {
            this.id = doc.id
            this._new_instance = false
            return this
          })
      }

      if (!this.id) {
        return insert()  
      }

      return this.constructor.findOne({id: this.id})
        .then(doc => {
          if (!doc) {
            return insert()
          }

          var obj = this.toObject()
          var changed = Object.entries(this._schema).reduce((r, k) =>  r || (doc[k[0]] !== obj[k[0]]), false)
          if (changed) {
            return this.constructor.update({id: this.id}, obj)
          }
          
          return this
        })
    }
  }





  return Model
}

export function createModel(name, schemaModel, meta, dataDir) {
  meta = meta || {}
  dataDir = dataDir || DATA_DIR
  
  const collectionName = meta.collection || name.toLowerCase()

  const datastore = new Datastore({
    filename: path.join(dataDir, collectionName + '.db'),
    autoload: true
  })

  return _createModel(name, schemaModel, meta, datastore)
}

export class RelationField {
  constructor(relatedModel) {
    this.relatedModel = relatedModel
  }
}